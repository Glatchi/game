<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>箱積みローグライク</title>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #f0f0f0;
            margin: 0;
            padding: 10px;
            max-width: 100vw;
            overflow-x: hidden;
        }
        .game-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
            width: 100%;
            max-width: 500px;
        }
        .header {
            text-align: center;
            margin-bottom: 5px;
            width: 100%;
        }
        .header h1 {
            font-size: 1.5rem;
            margin: 5px 0;
        }
        .turn-indicator {
            font-size: 20px;
            font-weight: bold;
            margin-bottom: 10px;
            text-align: center;
        }
        .game-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            background-color: #fff;
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .status {
            display: flex;
            justify-content: space-between;
            width: 100%;
            margin-bottom: 5px;
        }
        .player-info {
            display: flex;
            flex-direction: column;
            width: 48%;
            background-color: #fff;
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .player-stats {
            display: flex;
            flex-wrap: wrap;
            justify-content: space-between;
            margin-top: 5px;
            font-size: 0.85rem;
        }
        .stat-item {
            width: 48%;
            margin-bottom: 4px;
        }
        .health-bar {
            width: 100%;
            height: 20px;
            background-color: #e0e0e0;
            border-radius: 10px;
            overflow: hidden;
            margin-top: 5px;
        }
        .health-fill {
            height: 100%;
            background-color: #4caf50;
            transition: width 0.3s ease;
        }
        .enemy-health-fill {
            background-color: #f44336;
        }
        .status-effects {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin-top: 5px;
        }
        .status-effect {
            font-size: 0.75rem;
            padding: 3px 6px;
            border-radius: 10px;
            color: white;
        }
        .status-effect.buff {
            background-color: #4caf50;
        }
        .status-effect.debuff {
            background-color: #f44336;
        }
        .board {
            display: grid;
            grid-template-columns: repeat(6, 60px);
            grid-template-rows: repeat(8, 60px);
            gap: 2px;
            background-color: #2196F3;
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            margin: 0 auto;
            position: relative;
        }
        .cell {
            background-color: #fff;
            border-radius: 4px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .cell:hover {
            background-color: #e3f2fd;
        }
        .player-piece, .enemy-piece {
            width: 50px;
            height: 50px;
            border-radius: 4px;
            position: relative;
        }
        .player-piece {
            background-color: #ffeb3b;
        }
        .enemy-piece {
            background-color: #ff5722;
        }
        .boss-piece {
            background-color: #e91e63;
            box-shadow: 0 0 10px #ff0000;
        }
        .stage-indicator {
            position: absolute;
            top: 5px;
            right: 5px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 3px 8px;
            border-radius: 10px;
            font-size: 0.75rem;
            z-index: 10;
        }
        .boss-stage {
            color: #ff5722;
            font-weight: bold;
        }
        .cards {
            display: flex;
            gap: 10px;
            margin-top: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }
        .card {
            width: 120px;
            height: 160px;
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
            padding: 10px;
            cursor: pointer;
            transition: transform 0.2s;
            position: relative;
        }
        .card:hover {
            transform: translateY(-5px);
        }
        .card-title {
            font-weight: bold;
            text-align: center;
            margin-bottom: 5px;
        }
        .card-desc {
            font-size: 12px;
            flex-grow: 1;
        }
        .active-card {
            border: 3px solid #4caf50;
        }
        .consumable-card {
            border: 2px dashed #ff9800;
        }
        .cooldown {
            position: absolute;
            bottom: 5px;
            right: 5px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 0.75rem;
        }
        .log-panel {
            height: 200px;
            overflow-y: auto;
            border: 1px solid #ccc;
            padding: 10px;
            margin-top: 10px;
            background-color: #fff;
            font-size: 0.85rem;
            border-radius: 4px;
        }
        .log-entry {
            margin-bottom: 5px;
            border-bottom: 1px solid #eee;
            padding-bottom: 5px;
        }
        .log-turn {
            font-weight: bold;
            color: #2196F3;
        }
        .log-damage {
            color: #f44336;
        }
        .log-heal {
            color: #4caf50;
        }
        .log-effect {
            color: #9c27b0;
        }
        .log-calculation {
            margin-left: 20px;
            font-style: italic;
            color: #666;
        }
        .toggle-log-button {
            background-color: #2196F3;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            margin-top: 5px;
        }
        .messages-container {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
            max-width: 500px;
            display: flex;
            flex-direction: column;
            align-items: center;
            z-index: 1000;
            gap: 5px;
            pointer-events: none;
        }
        .message {
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            text-align: center;
            max-width: 100%;
            animation: fadeOut 3s forwards;
        }
        @keyframes fadeOut {
            0% { opacity: 1; }
            70% { opacity: 1; }
            100% { opacity: 0; }
        }
        .healing-effect {
            color: #4caf50;
            font-weight: bold;
        }
        .damage-effect {
            color: #f44336;
            font-weight: bold;
        }
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            padding: 20px;
            box-sizing: border-box;
        }
        .modal-title {
            color: white;
            font-size: 1.5rem;
            margin-bottom: 20px;
            text-align: center;
        }
        .modal-content {
            display: flex;
            justify-content: center;
            gap: 20px;
            flex-wrap: wrap;
            margin-bottom: 20px;
        }
        .modal-button {
            background-color: #4caf50;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
        }
        .game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            display: none;
        }
        .falling-piece {
            position: absolute;
            transition: top 0.5s ease;
        }
        .shop-item {
            position: relative;
            background-color: #fff;
            border-radius: 8px;
            padding: 10px;
            margin: 10px;
            width: 140px;
            height: 180px;
            display: flex;
            flex-direction: column;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            transition: transform 0.2s;
        }
        .shop-item:hover {
            transform: translateY(-5px);
        }
        .item-price {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background-color: gold;
            color: black;
            padding: 3px 8px;
            border-radius: 10px;
            font-weight: bold;
        }
        .boss-attack-effect {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 9999;
            animation: flash 0.5s;
        }
        @keyframes flash {
            0% { background-color: rgba(255, 0, 0, 0); }
            50% { background-color: rgba(255, 0, 0, 0.3); }
            100% { background-color: rgba(255, 0, 0, 0); }
        }
        .permanent-upgrade-effect {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #4caf50;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 0 0 10px #4caf50;
            animation: grow 1s forwards;
            pointer-events: none;
            z-index: 9999;
        }
        @keyframes grow {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
            50% { transform: translate(-50%, -50%) scale(1.2); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 0; }
        }
        .confusion-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(128, 0, 128, 0.3);
            pointer-events: none;
            z-index: 999;
            transition: opacity 2s;
        }
        .stage-clear-notification {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px 30px;
            border-radius: 10px;
            font-size: 1.5rem;
            text-align: center;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>箱積みローグライク</h1>
        <div class="turn-indicator" id="turnIndicator">あなたのターン</div>
    </div>
    
    <div class="game-info">
        <div>ステージ: <span id="stageNumber">1</span></div>
        <div>ターン: <span id="turnCounter">1</span></div>
        <div><span style="color: gold;">ゴールド: </span><span id="goldDisplay">0</span></div>
    </div>
    
    <div class="game-container">
        <div class="status">
            <div class="player-info">
                <h3>プレイヤー</h3>
                <div>HP: <span id="playerHP">100</span>/<span id="playerMaxHP">100</span></div>
                <div class="health-bar">
                    <div class="health-fill" id="playerHealthFill" style="width: 100%;"></div>
                </div>
                <div class="player-stats">
                    <div class="stat-item">攻撃力: <span id="playerAttack">10</span></div>
                    <div class="stat-item">防御力: <span id="playerDefense">0</span></div>
                    <div class="stat-item">連続ダメージ: <span id="consecutiveHits">0</span></div>
                    <div class="stat-item">クリティカル: <span id="criticalChance">0</span>%</div>
                </div>
                <div class="status-effects" id="playerStatusEffects"></div>
            </div>
            <div class="player-info">
                <h3>敵</h3>
                <div>HP: <span id="enemyHP">10</span>/<span id="enemyMaxHP">10</span></div>
                <div class="health-bar">
                    <div class="health-fill enemy-health-fill" id="enemyHealthFill" style="width: 100%;"></div>
                </div>
                <div class="player-stats">
                    <div class="stat-item">攻撃力: <span id="enemyAttack">5</span></div>
                    <div class="stat-item">防御力: <span id="enemyDefense">0</span></div>
                </div>
                <div class="status-effects" id="enemyStatusEffects"></div>
            </div>
        </div>
        
        <div class="board" id="gameBoard">
            <div class="stage-indicator" id="stageIndicator">ステージ 1</div>
        </div>
        
        <button class="toggle-log-button" id="toggleLogButton">ログを表示</button>
        <div class="log-panel" id="logPanel" style="display: none;"></div>
        
        <div class="info-panel">
            <h3>特殊カード (<span id="activeCardCount">0</span>/3)</h3>
            <div class="cards" id="cardsContainer"></div>
        </div>
    </div>
    
    <div class="messages-container" id="messagesContainer"></div>
    
    <div class="game-over" id="gameOverPanel">
        <h2 id="gameOverMessage"></h2>
        <button id="restartButton" class="modal-button">再挑戦</button>
    </div>

    <script>
// 																								イベントシステム
const GameEvents = {
    listeners: {},
    on(event, callback) {
        if (!this.listeners[event]) this.listeners[event] = [];
        this.listeners[event].push(callback);
        return callback;
    },
    off(event, callback) {
        if (!this.listeners[event]) return;
        const index = this.listeners[event].indexOf(callback);
        if (index !== -1) this.listeners[event].splice(index, 1);
    },
    trigger(event, ...args) {
        if (!this.listeners[event]) return [];
        return this.listeners[event].map(callback => callback(...args));
    }
};

// ゲーム状態管理
const GameState = {
    data: null,
    init() {
        this.data = {
            board: {
                grid: Array(8).fill().map(() => Array(6).fill(null)),
                width: 6,
                height: 8
            },
            player: {
                hp: 100,
                maxHp: 100,
                attack: 10,
                defense: 0,
                criticalChance: 0,
                statusEffects: []
            },
            enemy: {
                hp: 10,
                maxHp: 10,
                attack: 5,
                defense: 0,
                statusEffects: []
            },
            game: {
                currentPlayer: 'player',
                stage: 1,
                turn: 1,
                consecutiveHits: 0,
                lastColumn: -1,
                sameColumnCounter: 0,
                playerCards: [],
                activeCards: [],
                gameOver: false,
                cardSelectionInProgress: false,
                animationInProgress: false,
                masteryCounter: 0,
                masteryBonus: 0,
                isBossStage: false,
                reverseControls: false,
                gold: 0
            },
            stats: {
                totalDamageDealt: 0,
                totalDamageTaken: 0,
                enemiesDefeated: 0,
                bossesDefeated: 0,
                boxesPlaced: 0,
                linksCompleted: 0,
                goldEarned: 0,
                goldSpent: 0
            },
            permanentUpgrades: {
                maxHpBonus: 0,
                attackBonus: 0,
                defenseBonus: 0,
                criticalBonus: 0
            }
        };
        return this;
    },

    get(path) {
        return this._getNestedProperty(this.data, path);
    },
    
    set(path, value) {
        this._setNestedProperty(this.data, path, value);
        GameEvents.trigger('stateChanged', path, value);
        return value;
    },
    
    modifyStat(entity, stat, value) {
        const currentValue = this.get(`${entity}.${stat}`);
        const newValue = currentValue + value;
        this.set(`${entity}.${stat}`, newValue);
        return newValue;
    },
    
    addStatusEffect(entity, effect) {
        const effects = [...this.get(`${entity}.statusEffects`)];
        effects.push(effect);
        this.set(`${entity}.statusEffects`, effects);
        GameEvents.trigger('statusEffectAdded', entity, effect);
    },
    
    removeStatusEffect(entity, effectId) {
        const effects = this.get(`${entity}.statusEffects`).filter(e => e.id !== effectId);
        this.set(`${entity}.statusEffects`, effects);
        GameEvents.trigger('statusEffectRemoved', entity, effectId);
    },
    
    processStatusEffects() {
        ['player', 'enemy'].forEach(entity => {
            const effects = [...this.get(`${entity}.statusEffects`)];
            
            for (let i = effects.length - 1; i >= 0; i--) {
                const effect = effects[i];
                if (effect.effect) effect.effect(entity);
                
                if (effect.duration > 0) {
                    effect.duration--;
                    if (effect.duration === 0) {
                        if (effect.onExpire) effect.onExpire(entity);
                        
                        if (effect.attackBonus) {
                            this.modifyStat(entity, 'attack', -effect.attackBonus);
                            Logger.add('効果', `${effect.name}: 効果終了、攻撃力-${effect.attackBonus}`);
                        }
                        effects.splice(i, 1);
                    }
                }
            }
            
            this.set(`${entity}.statusEffects`, effects);
        });
        
        GameEvents.trigger('statusEffectsProcessed');
    },
    
    _getNestedProperty(obj, path) {
        return path.split('.').reduce((prev, curr) => prev && prev[curr], obj);
    },
    
    _setNestedProperty(obj, path, value) {
        const parts = path.split('.');
        const last = parts.pop();
        const target = parts.reduce((prev, curr) => prev && prev[curr], obj);
        if (target) target[last] = value;
    }
};

// カード効果タイプ
const EFFECT_TYPES = {
    DAMAGE_MODIFIER: 'damageModifier',
    STAT_MODIFIER: 'statModifier',
    TURN_ACTION: 'turnAction',
    CONDITION_CHECK: 'conditionCheck',
    STATUS_EFFECT: 'statusEffect',
    HEAL: 'heal'
};

// カードファクトリー
const CardFactory = {
    createCard(config) {
        const {id, name, description, isConsumable = false, effects = [], handlers = {}} = config;
        
        return {
            id, name, description, isActive: false, consumable: isConsumable,
            cooldown: 0, effects, ...handlers,
            
            activate() {
                this.isActive = true;
                if (this.onActivate) this.onActivate();
                return this;
            },
            
            deactivate() {
                this.isActive = false;
                if (this.onDeactivate) this.onDeactivate();
                return this;
            },
            
            use() {
                if (!this.consumable) return false;
                let used = false;
                if (this.onUse) used = this.onUse();
                return used;
            }
        };
    }
};

// ロガー
const Logger = {
    entries: [],
    
    add(type, message) {
        const timestamp = new Date().toLocaleTimeString();
        this.entries.push({
            type, message, turn: GameState.get('game.turn'), timestamp
        });
        
        this.update();
        return this;
    },
    
    update() {
        const logPanel = document.getElementById('logPanel');
        if (!logPanel) return this;
        
        const recentLogs = this.entries.slice(-20);
        logPanel.innerHTML = '';
        
        let currentTurn = null;
        
        for (const entry of recentLogs) {
            if (currentTurn !== entry.turn) {
                currentTurn = entry.turn;
                const turnHeader = document.createElement('div');
                turnHeader.className = 'log-turn';
                turnHeader.textContent = `===== ターン ${entry.turn} =====`;
                logPanel.appendChild(turnHeader);
            }
            
            const logEntry = document.createElement('div');
            logEntry.className = `log-entry log-${entry.type.toLowerCase()}`;
            
            if (entry.type === '計算') logEntry.className += ' log-calculation';
            
            logEntry.textContent = entry.message;
            logPanel.appendChild(logEntry);
        }
        
        logPanel.scrollTop = logPanel.scrollHeight;
        return this;
    },
    
    clear() {
        this.entries = [];
        return this;
    }
};

// UI管理
const UI = {
    elements: {},
    
    init() {
        this.elements = {
            gameBoard: document.getElementById('gameBoard'),
            playerHP: document.getElementById('playerHP'),
            playerMaxHP: document.getElementById('playerMaxHP'),
            enemyHP: document.getElementById('enemyHP'),
            enemyMaxHP: document.getElementById('enemyMaxHP'),
            playerHealthFill: document.getElementById('playerHealthFill'),
            enemyHealthFill: document.getElementById('enemyHealthFill'),
            turnIndicator: document.getElementById('turnIndicator'),
            stageNumber: document.getElementById('stageNumber'),
            turnCounter: document.getElementById('turnCounter'),
            gameOverPanel: document.getElementById('gameOverPanel'),
            gameOverMessage: document.getElementById('gameOverMessage'),
            restartButton: document.getElementById('restartButton'),
            cardsContainer: document.getElementById('cardsContainer'),
            playerAttack: document.getElementById('playerAttack'),
            playerDefense: document.getElementById('playerDefense'),
            enemyAttack: document.getElementById('enemyAttack'),
            enemyDefense: document.getElementById('enemyDefense'),
            consecutiveHits: document.getElementById('consecutiveHits'),
            criticalChance: document.getElementById('criticalChance'),
            activeCardCount: document.getElementById('activeCardCount'),
            logPanel: document.getElementById('logPanel'),
            toggleLogButton: document.getElementById('toggleLogButton'),
            messagesContainer: document.getElementById('messagesContainer'),
            stageIndicator: document.getElementById('stageIndicator'),
            goldDisplay: document.getElementById('goldDisplay')
        };
        
        this.elements.toggleLogButton.addEventListener('click', () => {
            if (this.elements.logPanel.style.display === 'none') {
                this.elements.logPanel.style.display = 'block';
                this.elements.toggleLogButton.textContent = 'ログを隠す';
            } else {
                this.elements.logPanel.style.display = 'none';
                this.elements.toggleLogButton.textContent = 'ログを表示';
            }
        });
        
        this.elements.restartButton.addEventListener('click', () => {
            this.elements.gameOverPanel.style.display = 'none';
            GameController.resetGame();
        });
        
        GameEvents.on('stateChanged', this.handleStateChange.bind(this));
        
        return this;
    },
    
    handleStateChange(path, value) {
        if (path.startsWith('player.') || path.startsWith('enemy.') || path.startsWith('game.')) {
            this.update();
        }
        
        if (path === 'game.turn' || path === 'game.currentPlayer') {
            this.updateTurnIndicator();
        }
        
        if (path === 'game.gameOver' && value === true) {
            this.showGameOver(GameState.get('player.hp') > 0);
        }
    },
    
    update() {
        this.elements.playerHP.textContent = GameState.get('player.hp');
        this.elements.playerMaxHP.textContent = GameState.get('player.maxHp') + GameState.get('permanentUpgrades.maxHpBonus');
        this.elements.playerAttack.textContent = GameState.get('player.attack');
        this.elements.playerDefense.textContent = GameState.get('player.defense');
        this.elements.consecutiveHits.textContent = GameState.get('game.consecutiveHits');
        this.elements.criticalChance.textContent = GameState.get('player.criticalChance');
        
        this.elements.enemyHP.textContent = GameState.get('enemy.hp');
        this.elements.enemyMaxHP.textContent = GameState.get('enemy.maxHp');
        this.elements.enemyAttack.textContent = GameState.get('enemy.attack');
        this.elements.enemyDefense.textContent = GameState.get('enemy.defense');
        
        const playerHpPercent = (GameState.get('player.hp') / (GameState.get('player.maxHp') + GameState.get('permanentUpgrades.maxHpBonus'))) * 100;
        this.elements.playerHealthFill.style.width = `${playerHpPercent}%`;
        
        const enemyHpPercent = (GameState.get('enemy.hp') / GameState.get('enemy.maxHp')) * 100;
        this.elements.enemyHealthFill.style.width = `${enemyHpPercent}%`;
        
        this.elements.stageNumber.textContent = GameState.get('game.stage');
        this.elements.turnCounter.textContent = GameState.get('game.turn');
        
        this.elements.goldDisplay.textContent = GameState.get('game.gold');
        
        this.elements.activeCardCount.textContent = GameState.get('game.activeCards').length;
        //                                                                                                                     Part3
        this.updateStatusEffectsDisplay();
        
        return this;
    },
    
    updateTurnIndicator() {
        const currentPlayer = GameState.get('game.currentPlayer');
        this.elements.turnIndicator.textContent = currentPlayer === 'player' ? 'あなたのターン' : '敵のターン';
        return this;
    },
    
    showGameOver(isWin) {
        this.elements.gameOverMessage.textContent = isWin ? 'ゲームクリア！おめでとう！' : 'ゲームオーバー...';
        this.elements.gameOverPanel.style.display = 'block';
        return this;
    },
    
    updateStatusEffectsDisplay() {
        const playerEffectsContainer = document.getElementById('playerStatusEffects');
        const enemyEffectsContainer = document.getElementById('enemyStatusEffects');
        
        playerEffectsContainer.innerHTML = '';
        enemyEffectsContainer.innerHTML = '';
        
        GameState.get('player.statusEffects').forEach(effect => {
            const effectElement = document.createElement('div');
            effectElement.className = `status-effect ${effect.type}`;
            effectElement.textContent = effect.duration > 0 
                ? `${effect.name} (${effect.duration})` 
                : effect.name;
            playerEffectsContainer.appendChild(effectElement);
        });
        
        GameState.get('enemy.statusEffects').forEach(effect => {
            const effectElement = document.createElement('div');
            effectElement.className = `status-effect ${effect.type}`;
            effectElement.textContent = effect.duration > 0 
                ? `${effect.name} (${effect.duration})` 
                : effect.name;
            enemyEffectsContainer.appendChild(effectElement);
        });
        
        return this;
    },
    
    initBoard() {
        const board = this.elements.gameBoard;
        board.innerHTML = '';
        
        const width = GameState.get('board.width');
        const height = GameState.get('board.height');
        
        const stageIndicator = document.createElement('div');
        stageIndicator.id = 'stageIndicator';
        stageIndicator.className = 'stage-indicator';
        stageIndicator.textContent = `ステージ ${GameState.get('game.stage')}`;
        
        if (GameState.get('game.isBossStage')) {
            stageIndicator.classList.add('boss-stage');
            stageIndicator.textContent += ' [ボス]';
        }
        
        board.appendChild(stageIndicator);
        
        for (let row = 0; row < height; row++) {
            for (let col = 0; col < width; col++) {
                const cell = document.createElement('div');
                cell.className = 'cell';
                cell.dataset.row = row;
                cell.dataset.col = col;
                board.appendChild(cell);
            }
        }
        
        board.addEventListener('click', event => {
            const cell = event.target.closest('.cell');
            if (!cell) return;
            
            const col = parseInt(cell.dataset.col);
            GameController.handleCellClick(col);
        });
        
        return this;
    },
    
    // 重要な修正: グリッドの内容を正確に反映する
    renderBoard() {
        const grid = GameState.get('board.grid');
        const width = GameState.get('board.width');
        const cells = this.elements.gameBoard.querySelectorAll('.cell');
        
        cells.forEach((cell, index) => {
            const row = Math.floor(index / width);
            const col = index % width;
            
            // セルの内容をクリア
            cell.innerHTML = '';
            
            // グリッドにあるものを表示
            const piece = grid[row][col];
            if (piece) {
                const pieceElement = document.createElement('div');
                pieceElement.className = piece === 'player' ? 'player-piece' : 'enemy-piece';
                
                if (piece === 'enemy' && GameState.get('game.isBossStage')) {
                    pieceElement.classList.add('boss-piece');
                }
                
                cell.appendChild(pieceElement);
            }
        });
        
        return this;
    },
    
    renderCards() {
        const container = this.elements.cardsContainer;
        container.innerHTML = '';
        
        const playerCards = GameState.get('game.playerCards');
        const activeCards = GameState.get('game.activeCards');
        
        playerCards.forEach(card => {
            const isActive = activeCards.some(c => c.id === card.id);
            const cardElement = document.createElement('div');
            cardElement.className = `card ${isActive ? 'active-card' : ''} ${card.consumable ? 'consumable-card' : ''}`;
            cardElement.dataset.cardId = card.id;
            
            cardElement.innerHTML = `
                <div class="card-title">${card.name}</div>
                <div class="card-desc">${card.description}</div>
            `;
            
            if (card.cooldown > 0) {
                const cooldownElement = document.createElement('div');
                cooldownElement.className = 'cooldown';
                cooldownElement.textContent = card.cooldown;
                cardElement.appendChild(cooldownElement);
                cardElement.style.opacity = '0.7';
            } else {
                cardElement.addEventListener('click', () => GameController.handleCardClick(card));
            }
            
            container.appendChild(cardElement);
        });
        
        return this;
    },
    
    showMessage(message, type = 'normal') {
        const container = this.elements.messagesContainer;
        const messageEl = document.createElement('div');
        messageEl.className = `message message-${type}`;
        messageEl.innerHTML = message;
        container.appendChild(messageEl);
        
        setTimeout(() => messageEl.remove(), 3000);
        
        return this;
    },
    
    showModal(title, content, buttons = []) {
        const modal = document.createElement('div');
        modal.className = 'modal';
        
        const titleEl = document.createElement('div');
        titleEl.className = 'modal-title';
        titleEl.innerHTML = title;
        modal.appendChild(titleEl);
        
        const contentEl = document.createElement('div');
        contentEl.className = 'modal-content';
        contentEl.appendChild(content);
        modal.appendChild(contentEl);
        
        buttons.forEach(button => {
            const buttonEl = document.createElement('button');
            buttonEl.className = 'modal-button';
            buttonEl.textContent = button.text;
            buttonEl.addEventListener('click', () => {
                modal.remove();
                if (button.callback) button.callback();
            });
            modal.appendChild(buttonEl);
        });
        
        document.body.appendChild(modal);
        return modal;
    },
    
    highlightColumn(col, color, callback) {
        const cells = [];
        const allCells = document.querySelectorAll('.cell');
        const boardHeight = GameState.get('board.height');
        const boardWidth = GameState.get('board.width');
        
        for (let row = 0; row < boardHeight; row++) {
            const index = row * boardWidth + col;
            cells.push(allCells[index]);
        }
        
        cells.forEach(cell => cell.style.backgroundColor = color);
        
        setTimeout(() => {
            cells.forEach(cell => cell.style.backgroundColor = '');
            if (callback) callback();
        }, 1000);
        
        return this;
    },
    
    // 修正: アニメーション処理の改善
    animatePieceFalling(row, col, player, callback) {
        const piece = document.createElement('div');
        piece.className = `${player}-piece falling-piece`;
        if (player === 'enemy' && GameState.get('game.isBossStage')) {
            piece.classList.add('boss-piece');
        }
        
        const boardRect = this.elements.gameBoard.getBoundingClientRect();
        const cellWidth = boardRect.width / GameState.get('board.width');
        const cellHeight = boardRect.height / GameState.get('board.height');
        
        piece.style.left = `${col * cellWidth + 5}px`;
        piece.style.top = '0px';
        piece.style.width = `${cellWidth - 10}px`;
        piece.style.height = `${cellHeight - 10}px`;
        
        this.elements.gameBoard.appendChild(piece);
        
        // グリッドを更新
        let gridCopy = JSON.parse(JSON.stringify(GameState.get('board.grid')));
        gridCopy[row][col] = player;
        GameState.set('board.grid', gridCopy);
        
        setTimeout(() => {
            const finalTop = row * cellHeight + 5;
            piece.style.top = `${finalTop}px`;
            
            piece.addEventListener('transitionend', () => {
                piece.remove();
                // アニメーション後に改めてレンダリング
                this.renderBoard();
                if (callback) callback();
            }, { once: true });
        }, 50);
        
        return this;
    },
    
    showCardSelection(cards, onSelect) {
        const modal = document.createElement('div');
        modal.className = 'modal';
        
        const title = document.createElement('div');
        title.className = 'modal-title';
        title.textContent = '新しいカードを1枚選んでください';
        modal.appendChild(title);
        
        const content = document.createElement('div');
        content.className = 'modal-content';
        
        cards.forEach(card => {
            const cardElement = document.createElement('div');
            cardElement.className = 'card';
            if (card.consumable) cardElement.classList.add('consumable-card');
            
            cardElement.innerHTML = `
                <div class="card-title">${card.name}</div>
                <div class="card-desc">${card.description}</div>
            `;
            
            cardElement.addEventListener('click', () => {
                modal.remove();
                onSelect(card);
            });
            
            content.appendChild(cardElement);
        });
        
        modal.appendChild(content);
        document.body.appendChild(modal);
        return modal;
    },
    
    showShop(items, gold, onPurchase, onSkip) {
        const modal = document.createElement('div');
        modal.className = 'modal';
        
        const title = document.createElement('div');
        title.className = 'modal-title';
        title.innerHTML = `<span style="color: gold">ショップ</span> - 所持金: <span id="shopGoldDisplay">${gold}</span>ゴールド`;
        modal.appendChild(title);
        
        const description = document.createElement('div');
        description.style.color = 'white';
        description.style.marginBottom = '10px';
        description.style.textAlign = 'center';
        description.textContent = 'アイテムを購入するか、スキップして次のステージへ進みます';
        modal.appendChild(description);
        
        const content = document.createElement('div');
        content.className = 'modal-content';
        
        items.forEach(item => {
            const itemElement = document.createElement('div');
            itemElement.className = 'shop-item';
            
            if (gold < item.price) itemElement.style.opacity = '0.5';
            
            itemElement.innerHTML = `
                <div class="card-title">${item.name}</div>
                <div class="card-desc">${item.description}</div>
                <div class="item-price">${item.price}G</div>
            `;
            
            itemElement.addEventListener('click', () => {
                if (gold >= item.price) {
                    onPurchase(item);
                    document.getElementById('shopGoldDisplay').textContent = GameState.get('game.gold');
                    itemElement.style.display = 'none';
                } else {
                    UI.showMessage('ゴールドが足りません！');
                }
            });
            
            content.appendChild(itemElement);
        });
        
        modal.appendChild(content);
        
        const skipButton = document.createElement('button');
        skipButton.textContent = '次のステージへ';
        skipButton.className = 'modal-button';
        skipButton.addEventListener('click', () => {
            modal.remove();
            onSkip();
        });
        
        modal.appendChild(skipButton);
        document.body.appendChild(modal);
        return modal;
    },
    
    showStageClearNotification(callback) {
        const notification = document.createElement('div');
        notification.className = 'stage-clear-notification';
        notification.textContent = `ステージ${GameState.get('game.stage')}クリア！`;
        document.body.appendChild(notification);
        
        setTimeout(() => {
            notification.remove();
            if (callback) callback();
        }, 1500);
        
        return this;
    }
};
//																				Part4
// カード定義
const CardDefinitions = {
    cards: [],
    
    init() {
        this.cards = [
            CardFactory.createCard({
                id: 'full-power', name: 'フルパワー', description: 'HPが満タンだと与えるダメージが+10される',
                handlers: { effect: (damage) => GameState.get('player.hp') === GameState.get('player.maxHp') ? damage + 10 : damage }
            }),
            
            CardFactory.createCard({
                id: 'iron-wall', name: '鉄壁', description: '2×2マスを自分の箱で埋めると、被ダメージが常に-5される',
                handlers: {
                    receiveDamageEffect: (damage) => GameController.checkFor2x2Square() ? Math.max(0, damage - 5) : damage,
                    onActivate: () => {
                        GameState.modifyStat('player', 'defense', 2);
                        Logger.add('効果', '鉄壁カード: 防御力+2');
                    },
                    onDeactivate: () => {
                        GameState.modifyStat('player', 'defense', -2);
                        Logger.add('効果', '鉄壁カード: 防御力-2');
                    }
                }
            }),
            
            CardFactory.createCard({
                id: 'lucky-seven', name: 'ラッキーセブン', description: '7ターンごとに50%の確率で追加で箱を置くことができる',
                handlers: {
                    onTurnStart: () => {
                        if (GameState.get('game.turn') % 7 === 0 && Math.random() < 0.5) {
                            Logger.add('効果', 'ラッキーセブン: 追加ターン発動！');
                            return true;
                        }
                        return false;
                    }
                }
            }),
            
            CardFactory.createCard({
                id: 'foundation', name: '縁の下の力持ち', description: '最も下段に自分の箱がある数分、攻撃力がプラスされる',
                handlers: {
                    effect: (damage) => damage + GameController.countBottomRowPieces(),
                    onActivate: () => {
                        const bottomPieces = GameController.countBottomRowPieces();
                        if (bottomPieces > 0) {
                            GameState.modifyStat('player', 'attack', bottomPieces);
                            Logger.add('効果', `縁の下の力持ち: 攻撃力+${bottomPieces} (底段の箱: ${bottomPieces}個)`);
                        }
                    },
                    onDeactivate: () => {
                        const bottomPieces = GameController.countBottomRowPieces();
                        if (bottomPieces > 0) {
                            GameState.modifyStat('player', 'attack', -bottomPieces);
                            Logger.add('効果', `縁の下の力持ち: 攻撃力-${bottomPieces}`);
                        }
                    },
                    onBoardChange: () => {
                        const activeCards = GameState.get('game.activeCards');
                        if (activeCards.some(card => card.id === 'foundation')) {
                            const currentBottomPieces = GameController.countBottomRowPieces();
                            const card = activeCards.find(c => c.id === 'foundation');
                            if (card.lastBottomPieces !== undefined) {
                                GameState.modifyStat('player', 'attack', -card.lastBottomPieces);
                                GameState.modifyStat('player', 'attack', currentBottomPieces);
                                Logger.add('効果', `縁の下の力持ち: 底段の箱が${card.lastBottomPieces}個→${currentBottomPieces}個に変化 (攻撃力${GameState.get('player.attack')})`);
                                card.lastBottomPieces = currentBottomPieces;
                            } else {
                                card.lastBottomPieces = currentBottomPieces;
                            }
                        }
                    }
                }
            }),
            
            CardFactory.createCard({
                id: 'heal-potion', name: '回復ポーション', description: '使用したら消える。HPを1~10のうちランダムな値回復する',
                isConsumable: true,
                handlers: {
                    onUse: () => {
                        const healAmount = Math.floor(Math.random() * 10) + 1;
                        const maxHp = GameState.get('player.maxHp') + GameState.get('permanentUpgrades.maxHpBonus');
                        GameState.set('player.hp', Math.min(maxHp, GameState.get('player.hp') + healAmount));
                        UI.showMessage(`<span class="healing-effect">${healAmount}ポイント回復しました！</span>`);
                        Logger.add('回復', `回復ポーション: HP+${healAmount}`);
                        return true;
                    }
                }
            }),
            
            CardFactory.createCard({
                id: 'mastery-path', name: '上達への道', description: '3ターン連続で敵にダメージを与えると、攻撃力+1。この値は効果が発動するごとに+1される',
                handlers: {
                    effect: (damage) => damage + GameState.get('game.masteryBonus'),
                    onDamageDealt: () => {
                        const newCounter = GameState.get('game.masteryCounter') + 1;
                        GameState.set('game.masteryCounter', newCounter);
                        
                        if (newCounter >= 3) {
                            const newBonus = GameState.get('game.masteryBonus') + 1;
                            GameState.set('game.masteryBonus', newBonus);
                            GameState.modifyStat('player', 'attack', 1);
                            GameState.set('game.masteryCounter', 0);
                            UI.showMessage(`上達への道: 攻撃力+${newBonus}に上昇！`);
                            Logger.add('効果', `上達への道: 攻撃力+${newBonus}に上昇！`);
                        }
                    },
                    onActivate: () => {
                        const bonus = GameState.get('game.masteryBonus');
                        GameState.modifyStat('player', 'attack', bonus);
                        Logger.add('効果', `上達への道: 攻撃力+${bonus}`);
                    },
                    onDeactivate: () => {
                        const bonus = GameState.get('game.masteryBonus');
                        GameState.modifyStat('player', 'attack', -bonus);
                        Logger.add('効果', `上達への道: 攻撃力-${bonus}`);
                    }
                }
            }),
            
            CardFactory.createCard({
                id: 'snake-line', name: '長蛇の列', description: '5つ連続でリンクすると+50ダメージ',
                handlers: {
                    effect: (damage, connections) => {
                        if (connections >= 5) {
                            Logger.add('効果', `長蛇の列: 5リンク以上のため、ダメージ+50 (${damage} → ${damage+50})`);
                            return damage + 50;
                        }
                        return damage;
                    }
                }
            }),
            
            CardFactory.createCard({
                id: 'meditation', name: '瞑想', description: '手番をスキップしてHPを10回復する',
                handlers: {
                    onUse: () => {
                        const maxHp = GameState.get('player.maxHp') + GameState.get('permanentUpgrades.maxHpBonus');
                        GameState.set('player.hp', Math.min(maxHp, GameState.get('player.hp') + 10));
                        UI.showMessage('<span class="healing-effect">瞑想: 10ポイント回復!</span>');
                        Logger.add('回復', '瞑想: HP+10');
                        
                        GameState.set('game.currentPlayer', 'enemy');
                        return true;
                    }
                }
            }),
            
            CardFactory.createCard({
                id: 'critical-hit', name: 'クリティカルヒット', description: '20%の確率でダメージが2倍になる',
                handlers: {
                    onActivate: () => {
                        GameState.modifyStat('player', 'criticalChance', 20);
                        Logger.add('効果', 'クリティカルヒットカード: クリティカル率+20%');
                    },
                    onDeactivate: () => {
                        GameState.modifyStat('player', 'criticalChance', -20);
                        Logger.add('効果', 'クリティカルヒットカード: クリティカル率-20%');
                    }
                }
            })
        ];
        return this;
    },
    
    getCard(id) {
        return this.cards.find(card => card.id === id);
    },
    
    getRandomCards(count, excludeIds = []) {
        const availableCards = this.cards.filter(card => !excludeIds.includes(card.id));
        const result = [];
        
        for (let i = 0; i < Math.min(count, availableCards.length); i++) {
            const randomIndex = Math.floor(Math.random() * availableCards.length);
            result.push(JSON.parse(JSON.stringify(availableCards[randomIndex])));
            availableCards.splice(randomIndex, 1);
        }
        
        return result;
    }
};

const BossAttacks = {
    attacks: [
        {
            id: 'double-strike', name: '二段攻撃', description: '2回連続で攻撃を行う',
            execute: () => {
                UI.showMessage('ボスの特殊攻撃: 二段攻撃！');
                Logger.add('ボス攻撃', '二段攻撃: 連続で2回攻撃');
                
                const damage1 = GameController.calculateDamage(20, GameState.get('enemy.attack'), GameState.get('player.defense'));
                GameState.modifyStat('player', 'hp', -damage1);
                GameState.modifyStat('stats', 'totalDamageTaken', damage1);
                UI.showMessage(`<span class="damage-effect">1撃目: ${damage1}ダメージ！</span>`);
                Logger.add('ダメージ', `ボスの1撃目: プレイヤーに${damage1}ダメージ`);
                
                setTimeout(() => {
                    if (GameState.get('player.hp') > 0) {
                        const damage2 = GameController.calculateDamage(15, GameState.get('enemy.attack'), GameState.get('player.defense'));
                        GameState.modifyStat('player', 'hp', -damage2);
                        GameState.modifyStat('stats', 'totalDamageTaken', damage2);
                        UI.showMessage(`<span class="damage-effect">2撃目: ${damage2}ダメージ！</span>`);
                        Logger.add('ダメージ', `ボスの2撃目: プレイヤーに${damage2}ダメージ`);
                    }
                }, 1000);
                
                return true;
            }
        }
    ],
    
    executeRandomAttack() {
        const availableAttacks = this.attacks.filter(attack => {
            if (attack.id === 'rage-mode' && GameState.get('enemy.hp') > GameState.get('enemy.maxHp') * 0.3) {
                return false;
            }
            return true;
        });
        
        if (availableAttacks.length > 0) {
            const randomIndex = Math.floor(Math.random() * availableAttacks.length);
            return availableAttacks[randomIndex].execute();
        }
        
        return false;
    }
};

const Shop = {
    generateItems() {
        const items = [];
        const stage = GameState.get('game.stage');
        
        items.push({
            type: 'hp', name: '回復薬', amount: 20, 
            price: 10 + (stage * 2), description: `HPを20回復する`
        });
        
        if (Math.random() < 0.7) {
            items.push({
                type: 'attack', name: '力の護符', amount: 3,
                price: 15 + (stage * 3), description: `攻撃力を+3する（一時的）`
            });
        }
        
        if (Math.random() < 0.7) {
            items.push({
                type: 'defense', name: '守りの印', amount: 2,
                price: 15 + (stage * 3), description: `防御力を+2する（一時的）`
            });
        }
        
        const playerCardIds = GameState.get('game.playerCards').map(card => card.id);
        const randomCards = CardDefinitions.getRandomCards(2, playerCardIds);
        
        randomCards.forEach(card => {
            items.push({
                type: 'card', name: card.name, data: card,
                price: card.consumable ? 20 + (stage * 2) : 30 + (stage * 4),
                description: card.description
            });
        });
        
        return items;
    },
    
    applyItemEffect(item) {
        switch(item.type) {
            case 'hp':
                const oldHP = GameState.get('player.hp');
                const maxHP = GameState.get('player.maxHp') + GameState.get('permanentUpgrades.maxHpBonus');
                GameState.set('player.hp', Math.min(maxHP, oldHP + item.amount));
                UI.showMessage(`<span class="healing-effect">${GameState.get('player.hp') - oldHP}HP回復しました！</span>`);
                Logger.add('回復', `ショップアイテム: HP+${GameState.get('player.hp') - oldHP}`);
                break;
                
            case 'attack':
                GameState.modifyStat('player', 'attack', item.amount);
                UI.showMessage(`攻撃力+${item.amount}！`);
                Logger.add('効果', `ショップアイテム: 攻撃力+${item.amount}`);
                break;
                
            case 'defense':
                GameState.modifyStat('player', 'defense', item.amount);
                UI.showMessage(`防御力+${item.amount}！`);
                Logger.add('効果', `ショップアイテム: 防御力+${item.amount}`);
                break;
                
            case 'card':
                const playerCards = [...GameState.get('game.playerCards')];
                playerCards.push(item.data);
                GameState.set('game.playerCards', playerCards);
                Logger.add('ショップ', `カード「${item.data.name}」を獲得`);
                break;
        }
    },
    
    show() {
        GameState.set('game.cardSelectionInProgress', true);
        
        const items = this.generateItems();
        const gold = GameState.get('game.gold');
        //																																Part5
        UI.showShop(items,
            gold,
            (item) => {
                GameState.modifyStat('game', 'gold', -item.price);
                GameState.modifyStat('stats', 'goldSpent', item.price);
                this.applyItemEffect(item);
                UI.showMessage(`「${item.name}」を購入しました！`);
                Logger.add('ショップ', `「${item.name}」を${item.price}ゴールドで購入`);
            },
            () => {
                GameController.handleStageComplete();
            }
        );
    }
};

const GameController = {
    init() {
        GameState.init();
        CardDefinitions.init();
        UI.init();
        
        this.addInitialCards();
        
        UI.initBoard();
        UI.renderBoard();
        UI.renderCards();
        
        Logger.add('システム', 'ゲーム開始！');
        Logger.add('システム', `ステージ1: 敵HP=${GameState.get('enemy.maxHp')}, 攻撃力=${GameState.get('enemy.attack')}, 防御力=${GameState.get('enemy.defense')}`);
        
        return this;
    },
    
    addInitialCards() {
        const initialCardPool = [
            CardDefinitions.getCard('full-power'),
            CardDefinitions.getCard('meditation'),
            CardDefinitions.getCard('critical-hit')
        ];
        
        const initialCards = [];
        for (let i = 0; i < 2; i++) {
            const randomIndex = Math.floor(Math.random() * initialCardPool.length);
            initialCards.push(JSON.parse(JSON.stringify(initialCardPool[randomIndex])));
            initialCardPool.splice(randomIndex, 1);
        }
        
        GameState.set('game.playerCards', initialCards);
    },
    
    resetGame() {
        GameState.init();
        this.addInitialCards();
        
        UI.initBoard();
        UI.renderBoard();
        UI.renderCards();
        UI.update();
        
        Logger.clear();
        Logger.add('システム', 'ゲーム再開始！');
        Logger.add('システム', `ステージ1: 敵HP=${GameState.get('enemy.maxHp')}, 攻撃力=${GameState.get('enemy.attack')}, 防御力=${GameState.get('enemy.defense')}`);
    },
    
    handleCellClick(col) {
        if (GameState.get('game.gameOver') || 
            GameState.get('game.currentPlayer') !== 'player' || 
            GameState.get('game.cardSelectionInProgress') || 
            GameState.get('game.animationInProgress')) return;
        
        if (GameState.get('game.reverseControls')) {
            col = GameState.get('board.width') - 1 - col;
        }
        
        const row = this.findAvailableRow(col);
        if (row === -1) return;
        
        GameState.modifyStat('stats', 'boxesPlaced', 1);
        
        const boxMasteryCard = GameState.get('game.playerCards').find(card => card.id === 'box-mastery');
        if (boxMasteryCard?.onPlacePiece) boxMasteryCard.onPlacePiece();
        
        GameState.set('game.animationInProgress', true);
        
        let attackBonus = 0;
        GameState.get('game.activeCards').forEach(card => {
            if (card.onPlacePiece) attackBonus += card.onPlacePiece(col);
        });
        
        if (attackBonus > 0) UI.update();
        
        UI.animatePieceFalling(row, col, 'player', () => {
            const connections = this.checkConnections(row, col, 'player');
            const didDealDamage = this.applyDamage(connections, 'player');
            
            if (didDealDamage) {
                const masteryCard = GameState.get('game.activeCards').find(card => card.id === 'mastery-path');
                if (masteryCard?.onDamageDealt) masteryCard.onDamageDealt();
                
                const lifeSapCard = GameState.get('game.activeCards').find(card => card.id === 'life-sap');
                if (lifeSapCard?.onDamageDealt) {
                    const damage = Math.min(GameState.get('enemy.maxHp'), GameState.get('enemy.hp') + connections) - GameState.get('enemy.hp');
                    lifeSapCard.onDamageDealt(damage);
                }
                
                const vitalityCard = GameState.get('game.activeCards').find(card => card.id === 'vitality-aura');
                if (vitalityCard?.onLinkCompleted && connections >= 3) {
                    vitalityCard.onLinkCompleted(connections);
                }
            } else {
                GameState.set('game.masteryCounter', 0);
            }
            
            GameState.get('game.activeCards').forEach(card => {
                if (card.onBoardChange) card.onBoardChange();
            });
            
            if (GameState.get('enemy.hp') <= 0) {
                this.handleEnemyDefeated(GameState.get('game.isBossStage'));
                GameState.set('game.animationInProgress', false);
                return;
            }
            
            this.updateCardCooldowns();
            
            const soulLinkCard = GameState.get('game.activeCards').find(card => card.id === 'soul-link');
            if (soulLinkCard?.onTurnEnd) soulLinkCard.onTurnEnd();
            
            GameState.set('game.currentPlayer', 'enemy');
            GameState.modifyStat('game', 'turn', 1);
            UI.update();
            
            Logger.add('ターン', `ターン${GameState.get('game.turn')}開始: 敵のターン`);
            
            GameState.set('game.animationInProgress', false);
            
            setTimeout(() => this.enemyTurn(), 500);
        });
    },
    
    findAvailableRow(col) {
        const grid = GameState.get('board.grid');
        const height = GameState.get('board.height');
        
        for (let row = height - 1; row >= 0; row--) {
            if (grid[row][col] === null) return row;
        }
        return -1;
    },
    
    enemyTurn() {
        if (GameState.get('game.gameOver') || 
            GameState.get('game.cardSelectionInProgress') || 
            GameState.get('game.animationInProgress')) return;
        
        let skipTurn = false;
        GameState.get('game.activeCards').forEach(card => {
            if (card.onTurnStart) {
                const result = card.onTurnStart();
                if (result === true) skipTurn = true;
            }
        });
        
        GameState.processStatusEffects();
        
        const fogEffect = GameState.get('enemy.statusEffects').find(effect => effect.missChance);
        if (fogEffect && Math.random() < fogEffect.missChance) {
            UI.showMessage('霧の効果！敵の攻撃が失敗した！');
            Logger.add('効果', '霧の効果: 敵の攻撃が失敗');
            
            GameState.set('game.currentPlayer', 'player');
            GameState.modifyStat('game', 'turn', 1);
            UI.update();
            Logger.add('ターン', `ターン${GameState.get('game.turn')}開始: プレイヤーのターン`);
            return;
        }
        
        if (GameState.get('game.isBossStage')) {
            const attackChance = 0.25 + (Math.floor(GameState.get('game.stage') / 5) * 0.05);
            
            if (Math.random() < attackChance || GameState.get('enemy.hp') <= GameState.get('enemy.maxHp') * 0.3) {
                if (BossAttacks.executeRandomAttack()) {
                    if (GameState.get('player.hp') <= 0) {
                        this.endGame(false);
                        return;
                    }
                    
                    setTimeout(() => {
                        if (!GameState.get('game.gameOver')) {
                            GameState.set('game.currentPlayer', 'player');
                            GameState.modifyStat('game', 'turn', 1);
                            UI.update();
                            Logger.add('ターン', `ターン${GameState.get('game.turn')}開始: プレイヤーのターン`);
                        }
                    }, 2000);
                    return;
                }
            }
        }
        
        GameState.set('game.animationInProgress', true);
        
        let col, row;
        do {
            col = Math.floor(Math.random() * GameState.get('board.width'));
            row = this.findAvailableRow(col);
        } while (row === -1);
        
        UI.animatePieceFalling(row, col, 'enemy', () => {
            const connections = this.checkConnections(row, col, 'enemy');
            this.applyDamage(connections, 'enemy');
            
            if (GameState.get('player.hp') <= 0) {
                this.endGame(false);
                GameState.set('game.animationInProgress', false);
                return;
            }
            
            const luckySeven = GameState.get('game.activeCards').find(card => card.id === 'lucky-seven');
            const extraTurn = luckySeven?.onTurnStart?.() || false;
            
            GameState.set('game.currentPlayer', 'player');
            GameState.modifyStat('game', 'turn', 1);
            UI.update();
            
            Logger.add('ターン', `ターン${GameState.get('game.turn')}開始: プレイヤーのターン`);
            
            GameState.set('game.animationInProgress', false);
            
            if (extraTurn) UI.showMessage('ラッキーセブン発動！追加で手を打てます！');
        });
    },
    
    checkConnections(row, col, player) {
        const directions = [[0, 1], [1, 0], [1, 1], [1, -1]];
        const grid = GameState.get('board.grid');
        const height = GameState.get('board.height');
        const width = GameState.get('board.width');
        
        let maxConnections = 0;
        
        for (const [dx, dy] of directions) {
            let count = 1;
            
            for (const [dirX, dirY] of [[dx, dy], [-dx, -dy]]) {
                let r = row + dirX;
                let c = col + dirY;
                
                while (
                    r >= 0 && r < height && 
                    c >= 0 && c < width && 
                    grid[r][c] === player
                ) {
                    count++;
                    r += dirX;
                    c += dirY;
                }
            }
            
            maxConnections = Math.max(maxConnections, count);
        }
        
        return maxConnections;
    },
    
    applyDamage(connections, player) {
        if (connections < 3) {
            if (player === 'player') GameState.set('game.consecutiveHits', 0);
            return false;
        }
        
        let baseDamage = connections === 3 ? 10 : 50;
        let damage = baseDamage;
        
        if (player === 'player') {
            Logger.add('ダメージ', `プレイヤーの攻撃: ${connections}リンク、基本ダメージ=${baseDamage}`);
            
            const snakeLine = GameState.get('game.activeCards').find(card => card.id === 'snake-line');
            if (snakeLine?.effect) damage = snakeLine.effect(damage, connections);
            
            const linkBoost = GameState.get('game.activeCards').find(card => card.id === 'link-boost');
            if (linkBoost?.effect) damage = linkBoost.effect(damage, connections);
            
            const attackBuffs = GameState.get('player.statusEffects').filter(effect => effect.attackBonus);
            attackBuffs.forEach(buff => {
                const oldDamage = damage;
                damage += buff.attackBonus;
                Logger.add('計算', `${buff.name}効果: ダメージ+${buff.attackBonus} (${oldDamage} → ${damage})`);
            });
            
            GameState.get('game.activeCards').forEach(card => {
                if (card.effect && !['snake-line', 'link-boost'].includes(card.id)) {
                    const oldDamage = damage;
                    damage = card.effect(damage, connections);
                    if (oldDamage !== damage) {
                        Logger.add('計算', `${card.name}効果: ダメージ変化 (${oldDamage} → ${damage})`);
                    }
                }
            });
            
            const preFinalDamage = damage;
            damage = this.calculateDamage(damage, GameState.get('player.attack'), GameState.get('enemy.defense'));
            Logger.add('計算', `攻撃力/防御力補正: ${preFinalDamage} × ${(1 + GameState.get('player.attack') / 20).toFixed(2)} - ${GameState.get('enemy.defense')} = ${damage}`);
            
            GameState.modifyStat('game', 'consecutiveHits', 1);
            
            const criticalCard = GameState.get('game.activeCards').find(card => card.id === 'critical-hit');
            if (criticalCard && Math.random() < 0.2) {
                const oldDamage = damage;
                damage *= 2;
                UI.showMessage('クリティカルヒット！ダメージ2倍！');
                Logger.add('効果', `クリティカルヒット: ダメージ2倍 (${oldDamage} → ${damage})`);
            }
            
            const defenseStance = GameState.get('enemy.statusEffects').find(effect => effect.damageReduction);
            if (defenseStance) {
                const oldDamage = damage;
                damage = Math.floor(damage * (1 - defenseStance.damageReduction));
                Logger.add('計算', `敵の${defenseStance.name}効果: ダメージ${defenseStance.damageReduction * 100}%減少 (${oldDamage} → ${damage})`);
            }
            
            GameState.modifyStat('enemy', 'hp', -damage);
            GameState.modifyStat('stats', 'totalDamageDealt', damage);
            Logger.add('ダメージ', `敵に${damage}ダメージ! 残りHP: ${GameState.get('enemy.hp')}/${GameState.get('enemy.maxHp')}`);
        } else {
            Logger.add('ダメージ', `敵の攻撃: ${connections}リンク、基本ダメージ=${baseDamage}`);
            
            const preFinalDamage = damage;
            damage = this.calculateDamage(damage, GameState.get('enemy.attack'), GameState.get('player.defense'));
            Logger.add('計算', `攻撃力/防御力補正: ${preFinalDamage} × ${(1 + GameState.get('enemy.attack') / 20).toFixed(2)} - ${GameState.get('player.defense')} = ${damage}`);
            
            GameState.get('game.activeCards').forEach(card => {
                if (card.receiveDamageEffect) {
                    const oldDamage = damage;
                    damage = card.receiveDamageEffect(damage);
                    if (oldDamage !== damage) {
                        Logger.add('計算', `${card.name}効果: 被ダメージ減少 (${oldDamage} → ${damage})`);
                    }
                }
            });
            
            GameState.modifyStat('player', 'hp', -damage);
            GameState.modifyStat('stats', 'totalDamageTaken', damage);
            Logger.add('ダメージ', `プレイヤーに${damage}ダメージ! 残りHP: ${GameState.get('player.hp')}/${GameState.get('player.maxHp') + GameState.get('permanentUpgrades.maxHpBonus')}`);
            
            const counterCard = GameState.get('game.activeCards').find(card => card.id === 'counter-stance');
            if (counterCard?.onDamageReceived) counterCard.onDamageReceived();
            
            const survivorCard = GameState.get('game.playerCards').find(card => card.id === 'survivor-instinct');
            if (survivorCard?.onDamageReceived) survivorCard.onDamageReceived(damage);
        }
        
        if (damage > 0) {
            let message = '';
            
            if (player === 'player') {
                message = GameState.get('game.consecutiveHits') > 1 
                    ? `${GameState.get('game.consecutiveHits')}連鎖！${connections}リンク！<span class="damage-effect">${damage}ダメージ！</span>`
                    : `${connections}リンク！<span class="damage-effect">${damage}ダメージ！</span>`;
            } else {
                message = `敵が${connections}リンク！<span class="damage-effect">${damage}ダメージ！</span>`;
            }
            
            UI.showMessage(message);
        }
        
        UI.update();
        return true;
    },
    
    calculateDamage(baseDamage, attackerAttack, defenderDefense) {
        let calculatedDamage = Math.floor(baseDamage * (1 + attackerAttack / 20)) - defenderDefense;
        return Math.max(1, calculatedDamage);
    },
    //																																Part6
    updateCardCooldowns() {
        const playerCards = GameState.get('game.playerCards').map(card => {
            if (card.cooldown > 0) card.cooldown--;
            return card;
        });
        
        GameState.set('game.playerCards', playerCards);
        UI.renderCards();
    },
    
    handleCardClick(card) {
        if (card.cooldown > 0 || 
            GameState.get('game.cardSelectionInProgress') || 
            GameState.get('game.animationInProgress')) return;
        
        if (card.consumable) {
            if (card.onUse && card.onUse()) {
                const playerCards = GameState.get('game.playerCards').filter(c => c.id !== card.id);
                const activeCards = GameState.get('game.activeCards').filter(c => c.id !== card.id);
                GameState.set('game.playerCards', playerCards);
                GameState.set('game.activeCards', activeCards);
            }
        } else {
            const activeCards = GameState.get('game.activeCards');
            const isActive = activeCards.some(c => c.id === card.id);
            
            if (isActive) {
                GameState.set('game.activeCards', activeCards.filter(c => c.id !== card.id));
                if (card.onDeactivate) card.onDeactivate();
            } else if (activeCards.length < 3) {
                GameState.set('game.activeCards', [...activeCards, card]);
                if (card.onActivate) card.onActivate();
            } else {
                UI.showMessage('アクティブカードは最大3枚までです');
                return;
            }
        }
        
        UI.renderCards();
        UI.update();
    },
    
    checkFor2x2Square() {
        const grid = GameState.get('board.grid');
        const height = GameState.get('board.height');
        const width = GameState.get('board.width');
        
        for (let row = 0; row < height - 1; row++) {
            for (let col = 0; col < width - 1; col++) {
                if (
                    grid[row][col] === 'player' &&
                    grid[row][col + 1] === 'player' &&
                    grid[row + 1][col] === 'player' &&
                    grid[row + 1][col + 1] === 'player'
                ) {
                    return true;
                }
            }
        }
        return false;
    },
    
    countBottomRowPieces() {
        const grid = GameState.get('board.grid');
        const bottomRow = GameState.get('board.height') - 1;
        let count = 0;
        
        for (let col = 0; col < GameState.get('board.width'); col++) {
            if (grid[bottomRow][col] === 'player') count++;
        }
        
        return count;
    },
    
    handleEnemyDefeated(isBoss) {
        let goldAmount = GameState.get('game.stage') * 5;
        if (isBoss) goldAmount *= 3;
        
        GameState.modifyStat('game', 'gold', goldAmount);
        GameState.modifyStat('stats', 'goldEarned', goldAmount);
        UI.showMessage(`<span style="color: gold">+${goldAmount}ゴールド獲得！</span>`);
        Logger.add('ゴールド', `+${goldAmount}ゴールド獲得! (合計: ${GameState.get('game.gold')})`);
        
        GameState.modifyStat('stats', 'enemiesDefeated', 1);
        
        const warriorCard = GameState.get('game.playerCards').find(card => card.id === 'warrior-spirit');
        if (warriorCard?.onEnemyDefeated) warriorCard.onEnemyDefeated();
        
        UI.showStageClearNotification(() => {
            this.showCardSelectionScreen();
        });
    },
    
    endGame(isWin) {
        GameState.set('game.gameOver', true);
        UI.elements.gameOverMessage.textContent = isWin ? 'ゲームクリア！おめでとう！' : 'ゲームオーバー...';
        UI.elements.gameOverPanel.style.display = 'block';
        Logger.add('システム', isWin ? 'ゲームクリア！おめでとう！' : 'ゲームオーバー...');
    },
    
    showCardSelectionScreen() {
        GameState.set('game.cardSelectionInProgress', true);
        
        if (GameState.get('game.stage') % 3 === 0) {
            Shop.show();
            return;
        }
        
        const playerCardIds = GameState.get('game.playerCards').map(card => card.id);
        const cardOptions = CardDefinitions.getRandomCards(2, playerCardIds);
        
        if (cardOptions.length === 0) {
            this.handleStageComplete([]);
            return;
        }
        
        UI.showCardSelection(cardOptions, (selectedCard) => {
            this.handleStageComplete([selectedCard]);
        });
    },
    
    handleStageComplete(selectedCards = []) {
        GameState.set('game.cardSelectionInProgress', false);
        
        const wasBossStage = GameState.get('game.isBossStage');
        
        const newStage = GameState.get('game.stage') + 1;
        GameState.set('game.stage', newStage);
        
        const isBossStage = newStage % 5 === 0;
        GameState.set('game.isBossStage', isBossStage);
        
        let baseEnemyHP = newStage * 10;
        let baseEnemyAttack = 5 + Math.floor(newStage / 2);
        let baseEnemyDefense = Math.floor(newStage / 3);
        
        if (isBossStage) {
            baseEnemyHP *= 2;
            baseEnemyAttack *= 1.5;
            baseEnemyDefense *= 1.5;
            Logger.add('システム', `=== ボスステージ ${newStage} ===`);
        }
        
        GameState.set('enemy.maxHp', baseEnemyHP);
        GameState.set('enemy.hp', baseEnemyHP);
        GameState.set('enemy.attack', Math.floor(baseEnemyAttack));
        GameState.set('enemy.defense', Math.floor(baseEnemyDefense));
        
        Logger.add('システム', `ステージ${newStage}: 敵HP=${baseEnemyHP}, 攻撃力=${Math.floor(baseEnemyAttack)}, 防御力=${Math.floor(baseEnemyDefense)}`);
        
        if (selectedCards.length > 0) {
            const playerCards = [...GameState.get('game.playerCards'), ...selectedCards];
            GameState.set('game.playerCards', playerCards);
            UI.showMessage(`新しいカード「${selectedCards[0].name}」を獲得しました！`);
            Logger.add('システム', `新しいカード「${selectedCards[0].name}」を獲得`);
        }
        
        if (wasBossStage) {
            GameState.modifyStat('stats', 'bossesDefeated', 1);
            
            const dragonCard = GameState.get('game.playerCards').find(card => card.id === 'dragon-blood');
            if (dragonCard?.onBossDefeated) dragonCard.onBossDefeated();
        }
        
        const activeCards = GameState.get('game.activeCards').filter(card => card.id !== 'ultimate-shield-effect');
        GameState.set('game.activeCards', activeCards);
        
        const playerStatusEffects = GameState.get('player.statusEffects').filter(effect => effect.duration === -1);
        GameState.set('player.statusEffects', playerStatusEffects);
        GameState.set('enemy.statusEffects', []);
        
        // 重要な修正: 新しいボード作成
        const newBoard = Array(GameState.get('board.height')).fill().map(() => Array(GameState.get('board.width')).fill(null));
        GameState.set('board.grid', newBoard);
        
        GameState.set('game.currentPlayer', 'player');
        GameState.set('game.consecutiveHits', 0);
        GameState.set('game.reverseControls', false);
        
        // ステージ表示を更新
        UI.initBoard();
        UI.renderBoard();
        UI.renderCards();
        UI.update();
    }
};

// 初期化とイベント登録
document.addEventListener('DOMContentLoaded', () => {
    GameController.init();
});
    </script>
</body>
</html>
